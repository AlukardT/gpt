const { Telegraf, Markup } = require('telegraf');
const express = require('express');
const path = require('path');
require('dotenv').config();

// Initialize bot with token from environment variables
const bot = new Telegraf(process.env.BOT_TOKEN);

// Initialize Express app for web server
const app = express();
app.use(express.json());
app.use('/balagan', express.static(path.join(__dirname, 'mafia-balagan')));

// In-memory data storage
let events = {}; // Store events by ID
let userProfiles = {}; // Store user profiles by Telegram ID
let eventRegistrations = {}; // Store registrations by event ID
let adminId = process.env.ADMIN_TELEGRAM_ID ? process.env.ADMIN_TELEGRAM_ID.toString() : null; // Admin Telegram ID
let eventIdCounter = 1; // Auto-incrementing event ID
let activeGames = {}; // Store active game states

// Predefined Mafia game roles
const mafiaRoles = [
    'mafia', 'mafia', 'don', 'doctor', 'detective', 
    'civilian', 'civilian', 'civilian', 'civilian', 'civilian',
    'civilian', 'civilian', 'civilian', 'civilian', 'civilian',
    'civilian', 'civilian', 'civilian', 'civilian', 'civilian'
];

// Helper function to get or create user profile
function getUserProfile(userId, username) {
    if (!userProfiles[userId]) {
        userProfiles[userId] = {
            id: userId,
            username: username || 'Unknown',
            nickname: null, // Game nickname set by admin
            gamesPlayed: 0,
            wins: 0,
            losses: 0
        };
    }
    // Update username if it has changed
    if (username && userProfiles[userId].username !== username) {
        userProfiles[userId].username = username;
    }
    return userProfiles[userId];
}

// Helper function to get upcoming events
function getUpcomingEvents() {
    const now = new Date();
    console.log('üìÖ Current time:', now.toISOString());
    console.log('üìÖ Available events:', Object.keys(events).length);
    
    const upcoming = Object.values(events).filter(event => {
        const eventDate = new Date(`${event.date} ${event.time}`);
        console.log(`üìÖ Event ${event.id}: ${event.date} ${event.time} -> ${eventDate.toISOString()}, Future: ${eventDate > now}`);
        return eventDate > now;
    });
    
    console.log('üìÖ Upcoming events count:', upcoming.length);
    return upcoming;
}

// Helper function to get registered players count for an event
function getRegisteredCount(eventId) {
    if (!eventRegistrations[eventId]) return 0;
    return Object.values(eventRegistrations[eventId]).reduce((total, reg) => total + reg.playerCount, 0);
}

// Start command - show main menu
bot.start((ctx) => {
    const userId = ctx.from.id;
    const username = ctx.from.username;
    
    // Create user profile if doesn't exist
    getUserProfile(userId, username);
    
    const isAdmin = userId.toString() === adminId;
    const buttons = [[Markup.button.callback('üé≠ –ê—Ñ–∏—à–∏', 'show_events')]];
    
    // –ú–∏–Ω–∏-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –¥–æ—Å—Ç—É–ø–Ω—ã —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω—É
    if (isAdmin) {
        const balaganUrl = process.env.REPLIT_DEV_DOMAIN ? `https://${process.env.REPLIT_DEV_DOMAIN}/balagan/` : 'https://localhost:5000/balagan/';

        buttons.push([Markup.button.webApp('üé≠ –ù–∞—à–∞ –ú–∞—Ñ–∏—è', balaganUrl)]);

    }
    
    const keyboard = Markup.inlineKeyboard(buttons);
    
    ctx.reply('–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –±–æ—Ç –¥–ª—è –∏–≥—Ä –≤ –ú–∞—Ñ–∏—é! üé≠\n\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –º–µ–Ω—é –Ω–∏–∂–µ –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏:', keyboard);
});

// Show posters with navigation
// –£–±–∏—Ä–∞–µ–º —Å—Ç–∞—Ä—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ - –æ–Ω –ø–µ—Ä–µ–Ω–µ—Å–µ–Ω –≤ main-server.js
// bot.action('show_events', (ctx) => {
//     const upcomingEvents = getUpcomingEvents();
//     
//     if (upcomingEvents.length === 0) {
//         const keyboard = Markup.inlineKeyboard([
//             [Markup.button.callback('üîô –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é', 'back_to_menu')]
//         ]);
//         ctx.editMessageText('üé≠ –ù–µ—Ç —Å–æ–∑–¥–∞–Ω–Ω—ã—Ö –∞—Ñ–∏—à.\n\nüí° –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä –º–æ–∂–µ—Ç —Å–æ–∑–¥–∞—Ç—å —Å–æ–±—ã—Ç–∏–µ –∫–æ–º–∞–Ω–¥–æ–π /create_event', keyboard);
//         return;
//     }
//     
//     // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–µ—Ä–≤—É—é –∞—Ñ–∏—à—É
//     showPoster(ctx, 0, upcomingEvents);
// });

// Function to show a single poster with navigation
function showPoster(ctx, index, events) {
    const event = events[index];
    const registeredCount = getRegisteredCount(event.id);
    
    // –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –¥–∞—Ç—É
    const eventDate = new Date(`${event.date} ${event.time}`);
    const options = { 
        weekday: 'long', 
        year: 'numeric', 
        month: 'long', 
        day: 'numeric' 
    };
    const formattedDate = eventDate.toLocaleDateString('ru-RU', options);
    
    const message = `üé≠ –ú–∞—Ñ–∏—è ‚Äî –±–ª–∏–∂–∞–π—à–∞—è –∏–≥—Ä–∞!
üìÖ –î–∞—Ç–∞: ${formattedDate}
üïñ –í—Ä–µ–º—è: ${event.time}
üìç –ú–µ—Å—Ç–æ: ${event.location}
${event.address ? `üìç –ê–¥—Ä–µ—Å: ${event.address}\n` : ''}
–ü—Ä–∏—Ö–æ–¥–∏ –Ω–∞ –∑–∞—Ö–≤–∞—Ç—ã–≤–∞—é—â—É—é –∏–≥—Ä—É –≤ –ú–∞—Ñ–∏—é!
–ü–æ–≥—Ä—É–∑–∏—Å—å –≤ –∞—Ç–º–æ—Å—Ñ–µ—Ä—É –∏–Ω—Ç—Ä–∏–≥, –Ω–µ–æ–∂–∏–¥–∞–Ω–Ω—ã—Ö —Å–æ—é–∑–æ–≤ –∏ –≥—Ä–æ–º–∫–∏—Ö —Ä–∞–∑–æ–±–ª–∞—á–µ–Ω–∏–π.

üí° –ß—Ç–æ —Ç–µ–±—è –∂–¥—ë—Ç:
        ‚Ä¢ –ù–æ–≤—ã–µ —Ä–æ–ª–∏ –∏ –Ω–µ–æ–∂–∏–¥–∞–Ω–Ω—ã–µ –ø–æ–≤–æ—Ä–æ—Ç—ã —Å—é–∂–µ—Ç–∞
        ‚Ä¢ –ñ–∏–≤–æ–µ –æ–±—â–µ–Ω–∏–µ –∏ –º–æ—Ä–µ —ç–º–æ—Ü–∏–π
        ‚Ä¢ –£–¥–æ–±–Ω—ã–π –∫–æ–Ω—Ç—Ä–æ–ª—å —á–µ—Ä–µ–∑ Telegram

üéü –ó–∞–ø–∏—Å–∞—Ç—å—Å—è: –Ω–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É "–ó–∞–ø–∏—Å–∞—Ç—å—Å—è" –Ω–∏–∂–µ.
–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–µ—Å—Ç –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–æ ‚Äî —É—Å–ø–µ–π –∑–∞–Ω—è—Ç—å —Å–≤–æ—ë –º–µ—Å—Ç–æ –∑–∞ —Å—Ç–æ–ª–æ–º!`;

    const buttons = [];
    
    // –ö–Ω–æ–ø–∫–∞ "–°–ª–µ–¥—É—é—â–µ–µ" –µ—Å–ª–∏ –µ—Å—Ç—å –µ—â–µ –∞—Ñ–∏—à–∏
    if (events.length > 1) {
        const nextIndex = (index + 1) % events.length;
        buttons.push([Markup.button.callback('‚û°Ô∏è –°–ª–µ–¥—É—é—â–µ–µ', `poster_${nextIndex}`)]);
    }
    
    // –ò–∫–æ–Ω–∫–∞ —Å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º –∏–≥—Ä–æ–∫–æ–≤
    buttons.push([Markup.button.callback(`üë• ${registeredCount}/${event.capacity} –∏–≥—Ä–æ–∫–æ–≤`, `players_${event.id}`)]);
    
    // –ö–Ω–æ–ø–∫–∞ "–ó–∞–ø–∏—Å–∞—Ç—å—Å—è"
    buttons.push([Markup.button.callback('‚úçÔ∏è –ó–∞–ø–∏—Å–∞—Ç—å—Å—è', `register_${event.id}`)]);
    
    // –ö–Ω–æ–ø–∫–∞ "–ù–∞–∑–∞–¥"
    buttons.push([Markup.button.callback('üîô –ù–∞–∑–∞–¥', 'back_to_menu')]);
    
    const keyboard = Markup.inlineKeyboard(buttons);
    
    if (ctx.callbackQuery) {
        ctx.editMessageText(message, keyboard);
    } else {
        ctx.reply(message, keyboard);
    }
}

// Handle poster navigation
bot.action(/poster_(\d+)/, (ctx) => {
    const index = parseInt(ctx.match[1]);
    const upcomingEvents = getUpcomingEvents();
    
    if (index >= 0 && index < upcomingEvents.length) {
        showPoster(ctx, index, upcomingEvents);
    }
});

// Show specific event details
bot.action(/event_(\d+)/, (ctx) => {
    const eventId = parseInt(ctx.match[1]);
    const event = events[eventId];
    
    if (!event) {
        ctx.answerCbQuery('–°–æ–±—ã—Ç–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ!');
        return;
    }
    
    const registeredCount = getRegisteredCount(eventId);
    
    let message = `üéØ *${event.title}*\n\n`;
    message += `üìç *–ú–µ—Å—Ç–æ:* ${event.location}\n`;
    message += `üè† *–ê–¥—Ä–µ—Å:* ${event.address}\n`;
    message += `üìÖ *–î–∞—Ç–∞:* ${event.date}\n`;
    message += `üïê *–í—Ä–µ–º—è:* ${event.time}\n`;
    message += `üë• *–ò–≥—Ä–æ–∫–∏:* ${registeredCount}/${event.capacity}\n`;
    
    const userId = ctx.from.id;
    const isAlreadyRegistered = eventRegistrations[eventId] && eventRegistrations[eventId][userId];
    
    const buttons = [
        [Markup.button.callback('üë• –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∏–≥—Ä–æ–∫–æ–≤', `players_${eventId}`)]
    ];
    
    if (isAlreadyRegistered) {
        buttons.push([Markup.button.callback('‚ùå –û—Ç–º–µ–Ω–∏—Ç—å –∑–∞–ø–∏—Å—å', `cancel_${eventId}`)]);
    } else {
        buttons.push([Markup.button.callback('‚úÖ –ó–∞–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –∏–≥—Ä—É', `register_${eventId}`)]);
    }
    
    // –ú–∏–Ω–∏-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –¥–æ—Å—Ç—É–ø–Ω—ã —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω—É
    const isAdmin = userId.toString() === adminId;
    if (isAdmin) {
        const balaganUrl = process.env.REPLIT_DEV_DOMAIN ? `https://${process.env.REPLIT_DEV_DOMAIN}/balagan/?eventId=${eventId}` : `https://localhost:5000/balagan/?eventId=${eventId}`;
        buttons.push([Markup.button.webApp('üé≠ –ù–∞—à–∞ –ú–∞—Ñ–∏—è', balaganUrl)]);

    }
    
    buttons.push([Markup.button.callback('üîô –ù–∞–∑–∞–¥ –∫ —Å–æ–±—ã—Ç–∏—è–º', 'show_events')]);
    
    const keyboard = Markup.inlineKeyboard(buttons);
    ctx.editMessageText(message, { parse_mode: 'Markdown', ...keyboard });
});

// Show registered players for an event
bot.action(/players_(\d+)/, (ctx) => {
    const eventId = parseInt(ctx.match[1]);
    const event = events[eventId];
    
    if (!event) {
        try {
            ctx.answerCbQuery('–°–æ–±—ã—Ç–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ!');
        } catch (err) {
            console.log('‚ö†Ô∏è Could not answer callback query (likely too old)');
        }
        return;
    }
    
    let message = `üë• *–ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∏–≥—Ä–æ–∫–∏ –Ω–∞ ${event.title}:*\n\n`;
    
    if (!eventRegistrations[eventId] || Object.keys(eventRegistrations[eventId]).length === 0) {
        message += '–ü–æ–∫–∞ –Ω–∏–∫–æ–≥–æ –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–ª–æ—Å—å.';
    } else {
        let playerNumber = 1;
        Object.values(eventRegistrations[eventId]).forEach(reg => {
            const username = reg.username || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π';
            const userProfile = userProfiles[reg.userId];
            const nickname = userProfile && userProfile.nickname ? userProfile.nickname : null;
            
            for (let i = 0; i < reg.playerCount; i++) {
                let playerDisplay = `@${username}`;
                if (nickname && i === 0) {
                    playerDisplay += ` (${nickname})`;
                }
                if (i > 0) {
                    playerDisplay += ` (–¥–æ–ø${i})`;
                }
                message += `${playerNumber}. ${playerDisplay}\n`;
                playerNumber++;
            }
        });
    }
    
    const keyboard = Markup.inlineKeyboard([
        [Markup.button.callback('üîô –ù–∞–∑–∞–¥ –∫ —Å–æ–±—ã—Ç–∏—é', `event_${eventId}`)]
    ]);
    
    ctx.editMessageText(message, keyboard);
});

// Show registration options
bot.action(/register_(\d+)/, (ctx) => {
    const eventId = parseInt(ctx.match[1]);
    const event = events[eventId];
    
    if (!event) {
        try {
            ctx.answerCbQuery('–°–æ–±—ã—Ç–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ!');
        } catch (err) {
            console.log('‚ö†Ô∏è Could not answer callback query (likely too old)');
        }
        return;
    }
    
    const registeredCount = getRegisteredCount(eventId);
    const availableSpots = event.capacity - registeredCount;
    
    if (availableSpots <= 0) {
        ctx.answerCbQuery('–°–æ–±—ã—Ç–∏–µ –∑–∞–ø–æ–ª–Ω–µ–Ω–æ!');
        return;
    }
    
    const userId = ctx.from.id;
    const isAlreadyRegistered = eventRegistrations[eventId] && eventRegistrations[eventId][userId];
    
    if (isAlreadyRegistered) {
        ctx.answerCbQuery('–í—ã —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –Ω–∞ —ç—Ç–æ —Å–æ–±—ã—Ç–∏–µ!');
        return;
    }
    
    let message = `üìù *–ó–∞–ø–∏—Å—å –Ω–∞ –∏–≥—Ä—É "${event.title}"*\n\n`;
    message += `–°–≤–æ–±–æ–¥–Ω–æ –º–µ—Å—Ç: ${availableSpots}\n\n`;
    message += '–°–∫–æ–ª—å–∫–æ —á–µ–ª–æ–≤–µ–∫ –±—É–¥–µ—Ç —É—á–∞—Å—Ç–≤–æ–≤–∞—Ç—å?';
    
    const buttons = [];
    for (let i = 1; i <= Math.min(4, availableSpots); i++) {
        const text = i === 1 ? "–Ø –ø—Ä–∏–¥—É" : `–Ø —Å ${i - 1} –¥–æ–ø`;
        buttons.push([Markup.button.callback(text, `confirm_reg_${eventId}_${i}`)]);
    }
    buttons.push([Markup.button.callback('üîô –ù–∞–∑–∞–¥ –∫ —Å–æ–±—ã—Ç–∏—é', `event_${eventId}`)]);
    
    const keyboard = Markup.inlineKeyboard(buttons);
    ctx.editMessageText(message, { parse_mode: 'Markdown', ...keyboard });
});

// Confirm registration
bot.action(/confirm_reg_(\d+)_(\d+)/, (ctx) => {
    const eventId = parseInt(ctx.match[1]);
    const playerCount = parseInt(ctx.match[2]);
    const userId = ctx.from.id;
    const username = ctx.from.username;
    
    const event = events[eventId];
    if (!event) {
        ctx.answerCbQuery('–°–æ–±—ã—Ç–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ!');
        return;
    }
    
    // Initialize event registrations if not exists
    if (!eventRegistrations[eventId]) {
        eventRegistrations[eventId] = {};
    }
    
    // Check if user is already registered
    if (eventRegistrations[eventId][userId]) {
        ctx.answerCbQuery('–í—ã —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã!');
        return;
    }
    
    // Check capacity
    const currentCount = getRegisteredCount(eventId);
    if (currentCount + playerCount > event.capacity) {
        ctx.answerCbQuery('–ù–µ —Ö–≤–∞—Ç–∞–µ—Ç —Å–≤–æ–±–æ–¥–Ω—ã—Ö –º–µ—Å—Ç!');
        return;
    }
    
    // Register user
    eventRegistrations[eventId][userId] = {
        userId: userId,
        username: username,
        playerCount: playerCount,
        registeredAt: new Date()
    };
    
    ctx.answerCbQuery('‚úÖ –í—ã —É—Å–ø–µ—à–Ω–æ –∑–∞–ø–∏—Å–∞–ª–∏—Å—å –Ω–∞ –∏–≥—Ä—É!');
    
    // Show updated event details
    const registeredCount = getRegisteredCount(eventId);
    let message = `üéØ *${event.title}*\n\n`;
    message += `üìç *–ú–µ—Å—Ç–æ:* ${event.location}\n`;
    message += `üè† *–ê–¥—Ä–µ—Å:* ${event.address}\n`;
    message += `üìÖ *–î–∞—Ç–∞:* ${event.date}\n`;
    message += `üïê *–í—Ä–µ–º—è:* ${event.time}\n`;
    message += `üë• *–ò–≥—Ä–æ–∫–∏:* ${registeredCount}/${event.capacity}\n\n`;
    message += `‚úÖ –í—ã –∑–∞–ø–∏—Å–∞–ª–∏—Å—å –Ω–∞ –∏–≥—Ä—É –Ω–∞ ${playerCount} ${playerCount === 1 ? '—á–µ–ª–æ–≤–µ–∫–∞' : '—á–µ–ª–æ–≤–µ–∫'}!`;
    
    const buttons = [
        [Markup.button.callback('üë• –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∏–≥—Ä–æ–∫–æ–≤', `players_${eventId}`)],
        [Markup.button.callback('‚ùå –û—Ç–º–µ–Ω–∏—Ç—å –∑–∞–ø–∏—Å—å', `cancel_${eventId}`)],
        [Markup.button.callback('üîô –ù–∞–∑–∞–¥ –∫ –∞—Ñ–∏—à–∞–º', 'show_events')]
    ];
    
    const keyboard = Markup.inlineKeyboard(buttons);
    ctx.editMessageText(message, { parse_mode: 'Markdown', ...keyboard });
});

// Cancel registration
bot.action(/cancel_(\d+)/, (ctx) => {
    const eventId = parseInt(ctx.match[1]);
    const userId = ctx.from.id;
    const event = events[eventId];
    
    if (!event) {
        ctx.answerCbQuery('–°–æ–±—ã—Ç–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ!');
        return;
    }
    
    // Check if user is registered
    if (!eventRegistrations[eventId] || !eventRegistrations[eventId][userId]) {
        ctx.answerCbQuery('–í—ã –Ω–µ –∑–∞–ø–∏—Å–∞–Ω—ã –Ω–∞ —ç—Ç–æ —Å–æ–±—ã—Ç–∏–µ!');
        return;
    }
    
    // Remove user registration
    delete eventRegistrations[eventId][userId];
    
    ctx.answerCbQuery('‚ùå –í–∞—à–∞ –∑–∞–ø–∏—Å—å –æ—Ç–º–µ–Ω–µ–Ω–∞!');
    
    // Show updated event details
    const registeredCount = getRegisteredCount(eventId);
    let message = `üéØ *${event.title}*\n\n`;
    message += `üìç *–ú–µ—Å—Ç–æ:* ${event.location}\n`;
    message += `üè† *–ê–¥—Ä–µ—Å:* ${event.address}\n`;
    message += `üìÖ *–î–∞—Ç–∞:* ${event.date}\n`;
    message += `üïê *–í—Ä–µ–º—è:* ${event.time}\n`;
    message += `üë• *–ò–≥—Ä–æ–∫–∏:* ${registeredCount}/${event.capacity}\n\n`;
    message += `‚ùå –í–∞—à–∞ –∑–∞–ø–∏—Å—å –Ω–∞ –∏–≥—Ä—É –æ—Ç–º–µ–Ω–µ–Ω–∞.`;
    
    const buttons = [
        [Markup.button.callback('üë• –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∏–≥—Ä–æ–∫–æ–≤', `players_${eventId}`)],
        [Markup.button.callback('‚úÖ –ó–∞–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –∏–≥—Ä—É', `register_${eventId}`)],
        [Markup.button.callback('üîô –ù–∞–∑–∞–¥ –∫ –∞—Ñ–∏—à–∞–º', 'show_events')]
    ];
    
    const keyboard = Markup.inlineKeyboard(buttons);
    ctx.editMessageText(message, { parse_mode: 'Markdown', ...keyboard });
});

// Back to main menu
bot.action('back_to_menu', (ctx) => {
    const isAdmin = ctx.from.id.toString() === adminId;
    const buttons = [[Markup.button.callback('üé≠ –ê—Ñ–∏—à–∏', 'show_events')]];
    
    // –ú–∏–Ω–∏-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –¥–æ—Å—Ç—É–ø–Ω—ã —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω—É
    if (isAdmin) {
        const balaganUrl = process.env.REPLIT_DEV_DOMAIN ? `https://${process.env.REPLIT_DEV_DOMAIN}/balagan/` : 'https://localhost:5000/balagan/';

        buttons.push([Markup.button.webApp('üé≠ –ù–∞—à–∞ –ú–∞—Ñ–∏—è', balaganUrl)]);

    }
    
    const keyboard = Markup.inlineKeyboard(buttons);
    
    ctx.editMessageText('–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –±–æ—Ç –¥–ª—è –∏–≥—Ä –≤ –ú–∞—Ñ–∏—é! üé≠\n\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –º–µ–Ω—é –Ω–∏–∂–µ –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏:', keyboard);
});

// Command to check admin status
bot.command('check_admin', (ctx) => {
    const userId = ctx.from.id.toString();
    const isAdmin = userId === adminId;
    
    let message = `üîç *–ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–¥–º–∏–Ω—Å–∫–∏—Ö –ø—Ä–∞–≤:*\n\n`;
    message += `üÜî –í–∞—à ID: ${userId}\n`;
    message += `üëë –ê–¥–º–∏–Ω ID: ${adminId || '–Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω'}\n`;
    message += `üõ°Ô∏è –°—Ç–∞—Ç—É—Å: ${isAdmin ? 'üëë –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä' : 'üë§ –û–±—ã—á–Ω—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å'}\n\n`;
    
    if (!isAdmin) {
        message += `üí° –ß—Ç–æ–±—ã —Å—Ç–∞—Ç—å –∞–¥–º–∏–Ω–æ–º, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ: /set_admin`;
    }
    
    ctx.reply(message, { parse_mode: 'Markdown' });
});

// Admin command to open virtual table
bot.command('table', (ctx) => {
    const userId = ctx.from.id.toString();
    
    if (userId !== adminId) {
        ctx.reply(`‚ùå –¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã –º–æ–≥—É—Ç –æ—Ç–∫—Ä—ã–≤–∞—Ç—å –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã–π —Å—Ç–æ–ª!\n\nüÜî –í–∞—à ID: ${userId}\nüëë –ê–¥–º–∏–Ω ID: ${adminId || '–Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω'}`);
        return;
    }
    
    const balaganUrl = process.env.REPLIT_DEV_DOMAIN ? `https://${process.env.REPLIT_DEV_DOMAIN}/balagan/` : 'https://localhost:5000/balagan/';
    const keyboard = Markup.inlineKeyboard([
        [Markup.button.webApp('üé≠ –ù–∞—à–∞ –ú–∞—Ñ–∏—è', balaganUrl)]
    ]);
    
    ctx.reply('üé≠ –û—Ç–∫—Ä—ã—Ç—å –ù–∞—à—É –ú–∞—Ñ–∏—é –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∏–≥—Ä–æ–π:', keyboard);
});

// Admin command to set admin
bot.command('set_admin', (ctx) => {
    // Allow anyone to set themselves as admin initially (can be modified for security)
    const newAdminId = ctx.from.id.toString();
    adminId = newAdminId;
    console.log(`üëë New admin set: ID = ${adminId}`);
    ctx.reply(`‚úÖ –í—ã –Ω–∞–∑–Ω–∞—á–µ–Ω—ã –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º!\nüÜî –í–∞—à –∞–¥–º–∏–Ω ID: ${adminId}`);
});

// Admin command to create event
bot.command('create_event', (ctx) => {
    const userId = ctx.from.id.toString();
    
    console.log(`üîç Admin check: User ID = ${userId}, Admin ID = ${adminId}`);
    
    if (userId !== adminId) {
        ctx.reply(`‚ùå –¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã –º–æ–≥—É—Ç —Å–æ–∑–¥–∞–≤–∞—Ç—å —Å–æ–±—ã—Ç–∏—è!\n\nüÜî –í–∞—à ID: ${userId}\nüëë –ê–¥–º–∏–Ω ID: ${adminId || '–Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω'}\n\nüí° –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /set_admin —á—Ç–æ–±—ã —Å—Ç–∞—Ç—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º`);
        return;
    }
    
    const args = ctx.message.text.split('\n').slice(1); // Skip the command line
    
    if (args.length < 6) {
        ctx.reply(`‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –≤—Å–µ –¥–µ—Ç–∞–ª–∏ —Å–æ–±—ã—Ç–∏—è –≤ —ç—Ç–æ–º —Ñ–æ—Ä–º–∞—Ç–µ:
/create_event
–ù–∞–∑–≤–∞–Ω–∏–µ
–ú–µ—Å—Ç–æ
–ê–¥—Ä–µ—Å
–î–∞—Ç–∞ (YYYY-MM-DD)
–í—Ä–µ–º—è (HH:MM)
–ö–æ–ª-–≤–æ –º–µ—Å—Ç

–ü—Ä–∏–º–µ—Ä:
/create_event
–ï–∂–µ–Ω–µ–¥–µ–ª—å–Ω–∞—è –ú–∞—Ñ–∏—è
–ü–∞—Ä–∫ –ì–æ—Ä—å–∫–æ–≥–æ
—É–ª. –ü–∞—Ä–∫–æ–≤–∞—è, 123, –ú–æ—Å–∫–≤–∞
2025-08-15
19:00
20`);
        return;
    }
    
    const [title, location, address, date, time, capacity] = args;
    
    // Validate date format
    const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
    if (!dateRegex.test(date)) {
        ctx.reply('‚ùå Please use YYYY-MM-DD format for date!');
        return;
    }
    
    // Validate time format
    const timeRegex = /^\d{2}:\d{2}$/;
    if (!timeRegex.test(time)) {
        ctx.reply('‚ùå Please use HH:MM format for time!');
        return;
    }
    
    // Validate capacity
    const capacityNum = parseInt(capacity);
    if (isNaN(capacityNum) || capacityNum <= 0) {
        ctx.reply('‚ùå Capacity must be a positive number!');
        return;
    }
    
    // Create event
    const eventId = eventIdCounter++;
    events[eventId] = {
        id: eventId,
        title: title.trim(),
        location: location.trim(),
        address: address.trim(),
        date: date.trim(),
        time: time.trim(),
        capacity: capacityNum,
        createdBy: userId,
        createdAt: new Date()
    };
    
    console.log('‚úÖ Event created:', eventId, title, date, time);
    console.log('üìä Total events now:', Object.keys(events).length);
    
    ctx.reply(`‚úÖ –°–æ–±—ã—Ç–∏–µ —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–æ!
üéØ *${title}*
üìç ${location}
üè† ${address}
üìÖ ${date} –≤ ${time}
üë• –ú–µ—Å—Ç: ${capacityNum} –∏–≥—Ä–æ–∫–æ–≤
üÜî ID —Å–æ–±—ã—Ç–∏—è: ${eventId}

üí° –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –º–æ–≥—É—Ç —É–≤–∏–¥–µ—Ç—å —ç—Ç–æ —Å–æ–±—ã—Ç–∏–µ –≤ —Ä–∞–∑–¥–µ–ª–µ "üìÖ –°–æ–±—ã—Ç–∏—è"`, { parse_mode: 'Markdown' });
});

// Admin command to start game
bot.command('start_game', async (ctx) => {
    const userId = ctx.from.id.toString();
    
    console.log(`üéÆ Game start check: User ID = ${userId}, Admin ID = ${adminId}`);
    
    if (userId !== adminId) {
        ctx.reply(`‚ùå –¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã –º–æ–≥—É—Ç –∑–∞–ø—É—Å–∫–∞—Ç—å –∏–≥—Ä—ã!\n\nüÜî –í–∞—à ID: ${userId}\nüëë –ê–¥–º–∏–Ω ID: ${adminId || '–Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω'}`);
        return;
    }
    
    const args = ctx.message.text.split(' ');
    if (args.length < 2) {
        ctx.reply('‚ùå Please provide event ID: /start_game [event_id]');
        return;
    }
    
    const eventId = parseInt(args[1]);
    const event = events[eventId];
    
    if (!event) {
        ctx.reply('‚ùå –°–æ–±—ã—Ç–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ!');
        return;
    }
    
    if (!eventRegistrations[eventId] || Object.keys(eventRegistrations[eventId]).length === 0) {
        ctx.reply('‚ùå –ù–∞ —ç—Ç–æ —Å–æ–±—ã—Ç–∏–µ –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–æ –∏–≥—Ä–æ–∫–æ–≤!');
        return;
    }
    
    // Get all registered players
    const registrations = Object.values(eventRegistrations[eventId]);
    const players = [];
    
    registrations.forEach(reg => {
        for (let i = 0; i < reg.playerCount; i++) {
            players.push({
                userId: reg.userId,
                username: reg.username,
                isMainPlayer: i === 0
            });
        }
    });
    
    if (players.length < 4) {
        ctx.reply('‚ùå –ù—É–∂–Ω–æ –º–∏–Ω–∏–º—É–º 4 –∏–≥—Ä–æ–∫–∞ –¥–ª—è –Ω–∞—á–∞–ª–∞ –∏–≥—Ä—ã!');
        return;
    }
    
    // Shuffle players and assign roles
    const shuffledPlayers = players.sort(() => Math.random() - 0.5);
    const gameRoles = mafiaRoles.slice(0, players.length);
    const shuffledRoles = gameRoles.sort(() => Math.random() - 0.5);
    
    // Initialize game in activeGames
    activeGames[eventId] = {
        phase: 'day',
        isActive: true,
        players: [],
        gameLog: [],
        lastUpdated: new Date()
    };
    
    ctx.reply(`üéÆ Starting game for "${event.title}"!\nüë• ${players.length} players\nüì§ Sending roles privately...\n\nüé≠ –û—Ç–∫—Ä–æ–π—Ç–µ Mafia BALAGAN –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∏–≥—Ä–æ–π!`);
    
    // Send roles privately to each player and update game state
    for (let i = 0; i < shuffledPlayers.length; i++) {
        const player = shuffledPlayers[i];
        const role = shuffledRoles[i];
        
        // Add to active game
        activeGames[eventId].players.push({
            id: i + 1,
            name: player.username,
            nickname: userProfiles[player.userId] && userProfiles[player.userId].nickname ? userProfiles[player.userId].nickname : null,
            role: role,
            status: 'alive',
            userId: player.userId
        });
        
        try {
            // Only send role to main players (not +1, +2, etc.)
            if (player.isMainPlayer) {
                await bot.telegram.sendMessage(
                    player.userId,
                    `üé≠ *Your role in "${event.title}":*\n\nüî• **${role.toUpperCase()}**\n\nGood luck! üçÄ`,
                    { parse_mode: 'Markdown' }
                );
                
                // Update user profile
                const userProfile = getUserProfile(player.userId, player.username);
                userProfile.gamesPlayed++;
            }
        } catch (error) {
            console.log(`Failed to send role to user ${player.userId}:`, error.message);
            ctx.reply(`‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ä–æ–ª—å @${player.username}. –í–æ–∑–º–æ–∂–Ω–æ, –æ–Ω –¥–æ–ª–∂–µ–Ω —Å–Ω–∞—á–∞–ª–∞ –∑–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞.`);
        }
    }
    
    // Add game application button
    const balaganUrl = process.env.REPLIT_DEV_DOMAIN ? `https://${process.env.REPLIT_DEV_DOMAIN}/balagan/?eventId=${eventId}` : `https://localhost:5000/balagan/?eventId=${eventId}`;
    const gameKeyboard = Markup.inlineKeyboard([
        [Markup.button.webApp('üé≠ Mafia BALAGAN', balaganUrl)]
    ]);
    
    ctx.reply('üé≠ –ò–≥—Ä–∞ –Ω–∞—á–∞–ª–∞—Å—å! –í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è:', gameKeyboard);
    
    // Send summary to admin
    let summary = `‚úÖ –ò–≥—Ä–∞ —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω–∞!\n\nüë• *–†–æ–ª–∏ –∏–≥—Ä–æ–∫–æ–≤:*\n`;
    for (let i = 0; i < shuffledPlayers.length; i++) {
        const player = shuffledPlayers[i];
        const role = shuffledRoles[i];
        summary += `‚Ä¢ @${player.username}: ${role}\n`;
    }
    
    ctx.reply(summary, { parse_mode: 'Markdown' });
});

// Command to show user profile
bot.command('profile', (ctx) => {
    const userId = ctx.from.id;
    const username = ctx.from.username;
    const profile = getUserProfile(userId, username);
    
    let message = `üë§ *–í–∞—à –ü—Ä–æ—Ñ–∏–ª—å:*\n\n`;
    message += `üÜî ID: ${profile.id}\n`;
    message += `üë§ –ù–∏–∫: @${profile.username}\n`;
    if (profile.nickname) {
        message += `üé≠ –ò–≥—Ä–æ–≤–æ–π –ø—Å–µ–≤–¥–æ–Ω–∏–º: ${profile.nickname}\n`;
    }
    message += `üéÆ –ò–≥—Ä —Å—ã–≥—Ä–∞–Ω–æ: ${profile.gamesPlayed}\n`;
    message += `üèÜ –ü–æ–±–µ–¥—ã: ${profile.wins}\n`;
    message += `üíÄ –ü–æ—Ä–∞–∂–µ–Ω–∏—è: ${profile.losses}\n`;
    
    if (profile.gamesPlayed > 0) {
        const winRate = ((profile.wins / profile.gamesPlayed) * 100).toFixed(1);
        message += `üìä –ü—Ä–æ—Ü–µ–Ω—Ç –ø–æ–±–µ–¥: ${winRate}%`;
    }
    
    ctx.reply(message, { parse_mode: 'Markdown' });
});

// Admin command to set player nickname
bot.command('set_nickname', (ctx) => {
    const userId = ctx.from.id.toString();
    
    if (userId !== adminId) {
        ctx.reply(`‚ùå –¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã –º–æ–≥—É—Ç —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—Ç—å –ø—Å–µ–≤–¥–æ–Ω–∏–º—ã!\n\nüÜî –í–∞—à ID: ${userId}\nüëë –ê–¥–º–∏–Ω ID: ${adminId || '–Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω'}`);
        return;
    }
    
    const args = ctx.message.text.split(' ').slice(1);
    if (args.length < 2) {
        ctx.reply('‚ùå –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /set_nickname @username –ø—Å–µ–≤–¥–æ–Ω–∏–º\n\n–ü—Ä–∏–º–µ—Ä: /set_nickname @john_doe –î–∂–æ–∫–µ—Ä');
        return;
    }
    
    const targetUsername = args[0].replace('@', '');
    const nickname = args.slice(1).join(' ');
    
    // Find user by username
    const targetUser = Object.values(userProfiles).find(profile => 
        profile.username && profile.username.toLowerCase() === targetUsername.toLowerCase()
    );
    
    if (!targetUser) {
        ctx.reply(`‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å @${targetUsername} –Ω–µ –Ω–∞–π–¥–µ–Ω. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –æ–Ω –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª –±–æ—Ç–∞ —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω —Ä–∞–∑.`);
        return;
    }
    
    // Set nickname
    targetUser.nickname = nickname;
    
    ctx.reply(`‚úÖ –ü—Å–µ–≤–¥–æ–Ω–∏–º —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!\nüë§ @${targetUser.username} ‚Üí üé≠ ${nickname}`);
});

// Command to get user's Telegram ID
bot.command('myid', (ctx) => {
    const userId = ctx.from.id;
    const username = ctx.from.username || '–Ω–µ—Ç username';
    const firstName = ctx.from.first_name || '';
    const lastName = ctx.from.last_name || '';
    
    ctx.reply(`üÜî *–í–∞—à Telegram ID:*\n\nüì± ID: \`${userId}\`\nüë§ –ò–º—è: ${firstName} ${lastName}\nüîó Username: @${username}\n\nüí° –°–∫–æ–ø–∏—Ä—É–π—Ç–µ ID –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤ –∏–≥—Ä—É`, { parse_mode: 'Markdown' });
});

// Command to open Mafia BALAGAN web app (admin only)
bot.command('balagan', (ctx) => {
    const userId = ctx.from.id.toString();
    
    if (userId !== adminId) {
        ctx.reply(`‚ùå –¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã –º–æ–≥—É—Ç –æ—Ç–∫—Ä—ã–≤–∞—Ç—å —Å—Ç–æ–ª –ú–∞—Ñ–∏–∏!\n\nüÜî –í–∞—à ID: ${userId}\nüëë –ê–¥–º–∏–Ω ID: ${adminId || '–Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω'}\n\nüí° –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –º–æ–≥—É—Ç –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Å–æ–±—ã—Ç–∏—è —á–µ—Ä–µ–∑ /start`);
        return;
    }
    
    const balaganUrl = process.env.REPLIT_DEV_DOMAIN ? 
        `https://${process.env.REPLIT_DEV_DOMAIN}/balagan/` : 
        'https://localhost:5000/balagan/';
    
    const keyboard = Markup.inlineKeyboard([
        [Markup.button.webApp('üé≠ –û—Ç–∫—Ä—ã—Ç—å —Å—Ç–æ–ª –ú–∞—Ñ–∏–∏', balaganUrl)]
    ]);
    
    ctx.reply(`üé≠ *Mafia BALAGAN*
    
–°—Ç–æ–ª –¥–ª—è –ø—Ä–æ–≤–µ–¥–µ–Ω–∏—è –∏–≥—Ä –≤ –ú–∞—Ñ–∏—é —Å:
‚Ä¢ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º –∏–≥—Ä–æ–∫–∞–º–∏ –∏ —Ä–æ–ª—è–º–∏
‚Ä¢ –ù–æ—á–Ω—ã–º–∏ –¥–µ–π—Å—Ç–≤–∏—è–º–∏ —Å –ø–æ–¥—Å–∫–∞–∑–∫–∞–º–∏  
‚Ä¢ –°–∏—Å—Ç–µ–º–æ–π –≥–æ–ª–æ—Å–æ–≤–∞–Ω–∏—è
‚Ä¢ –ò—Å—Ç–æ—Ä–∏–µ–π –∏–≥—Ä—ã

–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è:`, { 
        parse_mode: 'Markdown', 
        ...keyboard 
    });
});

// Admin command to remove player nickname
bot.command('remove_nickname', (ctx) => {
    const userId = ctx.from.id.toString();
    
    if (userId !== adminId) {
        ctx.reply(`‚ùå –¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã –º–æ–≥—É—Ç —É–¥–∞–ª—è—Ç—å –ø—Å–µ–≤–¥–æ–Ω–∏–º—ã!\n\nüÜî –í–∞—à ID: ${userId}\nüëë –ê–¥–º–∏–Ω ID: ${adminId || '–Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω'}`);
        return;
    }
    
    const args = ctx.message.text.split(' ').slice(1);
    if (args.length < 1) {
        ctx.reply('‚ùå –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /remove_nickname @username\n\n–ü—Ä–∏–º–µ—Ä: /remove_nickname @john_doe');
        return;
    }
    
    const targetUsername = args[0].replace('@', '');
    
    // Find user by username
    const targetUser = Object.values(userProfiles).find(profile => 
        profile.username && profile.username.toLowerCase() === targetUsername.toLowerCase()
    );
    
    if (!targetUser) {
        ctx.reply(`‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å @${targetUsername} –Ω–µ –Ω–∞–π–¥–µ–Ω.`);
        return;
    }
    
    if (!targetUser.nickname) {
        ctx.reply(`‚ùå –£ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è @${targetUsername} –Ω–µ—Ç –ø—Å–µ–≤–¥–æ–Ω–∏–º–∞.`);
        return;
    }
    
    const oldNickname = targetUser.nickname;
    targetUser.nickname = null;
    
    ctx.reply(`‚úÖ –ü—Å–µ–≤–¥–æ–Ω–∏–º —É–¥–∞–ª–µ–Ω!\nüë§ @${targetUser.username} (–±—ã–ª: üé≠ ${oldNickname})`);
});

// Admin command to list all players with nicknames
bot.command('list_nicknames', (ctx) => {
    const userId = ctx.from.id.toString();
    
    if (userId !== adminId) {
        ctx.reply(`‚ùå –¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã –º–æ–≥—É—Ç –ø—Ä–æ—Å–º–∞—Ç—Ä–∏–≤–∞—Ç—å —Å–ø–∏—Å–æ–∫ –ø—Å–µ–≤–¥–æ–Ω–∏–º–æ–≤!\n\nüÜî –í–∞—à ID: ${userId}\nüëë –ê–¥–º–∏–Ω ID: ${adminId || '–Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω'}`);
        return;
    }
    
    const playersWithNicknames = Object.values(userProfiles).filter(profile => profile.nickname);
    
    if (playersWithNicknames.length === 0) {
        ctx.reply('üìù –ù–µ—Ç –∏–≥—Ä–æ–∫–æ–≤ —Å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–º–∏ –ø—Å–µ–≤–¥–æ–Ω–∏–º–∞–º–∏.');
        return;
    }
    
    let message = 'üìù *–°–ø–∏—Å–æ–∫ –∏–≥—Ä–æ–∫–æ–≤ —Å –ø—Å–µ–≤–¥–æ–Ω–∏–º–∞–º–∏:*\n\n';
    playersWithNicknames.forEach((profile, index) => {
        message += `${index + 1}. @${profile.username} ‚Üí üé≠ ${profile.nickname}\n`;
    });
    
    ctx.reply(message, { parse_mode: 'Markdown' });
});

// Command to update game results (admin only)
bot.command('update_wins', (ctx) => {
    const userId = ctx.from.id.toString();
    
    if (userId !== adminId) {
        ctx.reply(`‚ùå –¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã –º–æ–≥—É—Ç –æ–±–Ω–æ–≤–ª—è—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –∏–≥—Ä!\n\nüÜî –í–∞—à ID: ${userId}\nüëë –ê–¥–º–∏–Ω ID: ${adminId || '–Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω'}`);
        return;
    }
    
    const args = ctx.message.text.split(' ').slice(1);
    if (args.length === 0) {
        ctx.reply('‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –Ω–∏–∫–∏ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π: /update_wins @username1 @username2');
        return;
    }
    
    let updated = 0;
    args.forEach(arg => {
        const username = arg.replace('@', '');
        // Find user by username
        const user = Object.values(userProfiles).find(profile => 
            profile.username && profile.username.toLowerCase() === username.toLowerCase()
        );
        
        if (user) {
            user.wins++;
            updated++;
        }
    });
    
    ctx.reply(`‚úÖ –û–±–Ω–æ–≤–ª–µ–Ω—ã –ø–æ–±–µ–¥—ã –¥–ª—è ${updated} –∏–≥—Ä–æ–∫–æ–≤.`);
});

// Error handling
bot.catch((err, ctx) => {
    console.log(`Error for ${ctx.updateType}:`, err);
    
    // Handle old callback queries gracefully
    if (err.message && (err.message.includes('query is too old') || err.message.includes('query ID is invalid'))) {
        console.log('‚ö†Ô∏è Ignoring old callback query');
        return;
    }
    
    if (ctx.answerCbQuery) {
        try {
            ctx.answerCbQuery('‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.');
        } catch (callbackError) {
            console.log('Could not answer callback query:', callbackError.message);
        }
    } else {
        ctx.reply('‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.');
    }
});

// Launch bot with cleanup
console.log('üîÑ Starting bot launch...');
console.log('üîë Bot token exists:', !!process.env.BOT_TOKEN);
console.log('üë§ Admin ID exists:', !!process.env.ADMIN_TELEGRAM_ID);
console.log('üëë Admin ID value:', process.env.ADMIN_TELEGRAM_ID);
console.log('üåê Attempting to connect to Telegram...');

bot.launch({
    dropPendingUpdates: true
})
    .then(() => {
        console.log('ü§ñ –ë–æ—Ç –¥–ª—è –∏–≥—Ä –≤ –ú–∞—Ñ–∏—é –∑–∞–ø—É—â–µ–Ω!');
        console.log('üìù –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏:');
        console.log('1. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ç–æ–∫–µ–Ω –±–æ—Ç–∞ –≤ Replit Secrets');
        console.log('2. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å ID –∞–¥–º–∏–Ω–∞ –≤ Replit Secrets');
        console.log('3. –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –º–æ–≥—É—Ç –Ω–∞—á–∞—Ç—å —Å /start');
        console.log('4. –ê–¥–º–∏–Ω –º–æ–∂–µ—Ç —Å–æ–∑–¥–∞–≤–∞—Ç—å —Å–æ–±—ã—Ç–∏—è —Å /create_event');
        console.log('5. –ê–¥–º–∏–Ω –º–æ–∂–µ—Ç –∑–∞–ø—É—Å–∫–∞—Ç—å –∏–≥—Ä—ã —Å /start_game [event_id]');
        console.log('6. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /set_admin –¥–ª—è –ø–µ—Ä–≤–æ–π –Ω–∞—Å—Ç—Ä–æ–π–∫–∏');
    })
    .catch(err => {
        console.error('‚ùå Failed to start bot:', err.message);
        console.error('üí° Please check:');
        console.error('1. Bot token is correct and active');
        console.error('2. No other bot instance is running');
        console.error('3. Network connection is stable');
        process.exit(1);
    });

// API Routes for Web App

// Get game data for specific event
app.get('/api/game/:eventId', (req, res) => {
    const eventId = parseInt(req.params.eventId);
    const event = events[eventId];
    
    if (!event) {
        return res.status(404).json({ error: 'Event not found' });
    }
    
    // Get players from event registrations
    const players = [];
    if (eventRegistrations[eventId]) {
        let playerId = 1;
        Object.values(eventRegistrations[eventId]).forEach(reg => {
            const userProfile = userProfiles[reg.userId];
            for (let i = 0; i < reg.playerCount; i++) {
                players.push({
                    id: playerId++,
                    name: reg.username,
                    nickname: userProfile && userProfile.nickname ? userProfile.nickname : null,
                    role: null, // Will be assigned when game starts
                    status: 'alive'
                });
            }
        });
    }
    
    const gameData = {
        eventId: eventId,
        title: event.title,
        players: players,
        phase: activeGames[eventId] ? activeGames[eventId].phase : 'waiting',
        isActive: activeGames[eventId] ? activeGames[eventId].isActive : false
    };
    
    res.json(gameData);
});

// Update game state
app.post('/api/game/update', (req, res) => {
    try {
        const { eventId, phase, isActive, players, gameLog } = req.body;
        
        // If no eventId, use first available active game or create demo
        let targetEventId = eventId;
        if (!eventId) {
            const activeEventIds = Object.keys(activeGames);
            if (activeEventIds.length > 0) {
                targetEventId = activeEventIds[0];
            } else {
                targetEventId = 'demo';
            }
        }
        
        // Update game state
        if (!activeGames[targetEventId]) {
            activeGames[targetEventId] = {};
        }
        
        activeGames[targetEventId] = {
            phase: phase || 'waiting',
            isActive: isActive || false,
            players: players || [],
            gameLog: gameLog || [],
            lastUpdated: new Date()
        };
        
        res.json({ success: true, eventId: targetEventId });
    } catch (error) {
        console.error('Error updating game state:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// BALAGAN API Routes

// Get game data for BALAGAN
app.get('/api/balagan/game/:eventId', (req, res) => {
    const eventId = parseInt(req.params.eventId);
    const event = events[eventId];
    
    if (!event) {
        return res.status(404).json({ error: 'Event not found' });
    }
    
    // Get players from event registrations
    const players = [];
    if (eventRegistrations[eventId]) {
        let playerId = 1;
        Object.values(eventRegistrations[eventId]).forEach(reg => {
            const userProfile = userProfiles[reg.userId];
            for (let i = 0; i < reg.playerCount; i++) {
                players.push({
                    id: playerId++,
                    name: reg.username,
                    nickname: userProfile && userProfile.nickname ? userProfile.nickname : null,
                    role: null, // Will be assigned when game starts
                    status: 'alive',
                    seatNumber: playerId // Default seat assignment
                });
            }
        });
    }
    
    const gameData = {
        eventId: eventId,
        title: event.title,
        players: players,
        phase: activeGames[eventId] ? activeGames[eventId].phase : 'setup',
        isActive: activeGames[eventId] ? activeGames[eventId].isActive : false
    };
    
    res.json(gameData);
});

// Assign roles in BALAGAN
app.post('/api/balagan/assign-roles', async (req, res) => {
    try {
        const { players, gameMode } = req.body;
        
        // Send roles to players via Telegram
        for (const player of players) {
            if (player.role && player.username) {
                try {
                    // Find user ID by username
                    const userProfile = Object.values(userProfiles).find(profile => 
                        profile.username && profile.username.toLowerCase() === player.username.toLowerCase()
                    );
                    
                    if (userProfile) {
                        await bot.telegram.sendMessage(
                            userProfile.id,
                            `üé≠ *Mafia BALAGAN - –í–∞—à–∞ —Ä–æ–ª—å:*\n\n${getRoleEmoji(player.role)} **${getRoleName(player.role).toUpperCase()}**\n\n–£–¥–∞—á–∏ –≤ –∏–≥—Ä–µ! üçÄ`,
                            { parse_mode: 'Markdown' }
                        );
                    }
                } catch (error) {
                    console.log(`Failed to send role to user ${player.username}:`, error.message);
                }
            }
        }
        
        res.json({ success: true, message: 'Roles assigned successfully' });
    } catch (error) {
        console.error('Error assigning roles:', error);
        res.status(500).json({ error: 'Failed to assign roles' });
    }
});

function getRoleEmoji(role) {
    const roleEmojis = {
        don: 'üëë',
        mafia: 'üî¥',
        consigliere: 'üé≠',
        capo: '‚öîÔ∏è',
        commissar: 'üîç',
        doctor: 'üíä',
        lover: 'üíã',
        bomber: 'üí£',
        civilian: 'üë§',
        maniac: 'üî™',
        kamikaze: 'üí•',
        werewolf: 'üê∫'
    };
    return roleEmojis[role] || '‚ùì';
}

function getRoleName(role) {
    const roleNames = {
        don: '–î–æ–Ω',
        mafia: '–ú–∞—Ñ–∏—è',
        consigliere: '–ö–æ–Ω—Å–∏–ª—å–µ—Ä–∏',
        capo: '–ö–∞–ø–æ',
        commissar: '–ö–æ–º–∏—Å—Å–∞—Ä',
        doctor: '–î–æ–∫—Ç–æ—Ä',
        lover: '–õ—é–±–æ–≤–Ω–∏—Ü–∞',
        bomber: '–ü–æ–¥—Ä—ã–≤–Ω–∏–∫',
        civilian: '–ú–∏—Ä–Ω—ã–π –∂–∏—Ç–µ–ª—å',
        maniac: '–ú–∞–Ω—å—è–∫',
        kamikaze: '–ö–∞–º–∏–∫–∞–¥–∑–µ',
        werewolf: '–û–±–æ—Ä–æ—Ç–µ–Ω—å'
    };
    return roleNames[role] || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ';
}

// Add root route to redirect to Mafia BALAGAN
// API endpoint to get upcoming events
app.get('/api/events/upcoming', async (req, res) => {
    try {
        const upcomingEvents = Object.values(events)
            .filter(event => {
                const eventDate = new Date(`${event.date}T${event.time}`);
                return eventDate > new Date();
            })
            .sort((a, b) => {
                const dateA = new Date(`${a.date}T${a.time}`);
                const dateB = new Date(`${b.date}T${b.time}`);
                return dateA - dateB;
            });
        
        res.json(upcomingEvents);
    } catch (error) {
        console.error('‚ùå Error fetching upcoming events:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// API endpoint to get event registrations
app.get('/api/events/:eventId/registrations', async (req, res) => {
    try {
        const eventId = parseInt(req.params.eventId);
        const registrations = eventRegistrations[eventId] || {};
        
        const registrationsList = Object.values(registrations).map(reg => ({
            userId: reg.userId,
            username: reg.username,
            playerCount: reg.playerCount,
            registeredAt: reg.registeredAt
        }));
        
        res.json(registrationsList);
    } catch (error) {
        console.error('‚ùå Error fetching event registrations:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// API endpoint to send roles to players from web app
app.post('/api/send-roles', async (req, res) => {
    try {
        const { players, gameTitle } = req.body;
        
        if (!players || !Array.isArray(players)) {
            return res.status(400).json({ error: 'Players array is required' });
        }
        
        console.log('üì§ Sending roles to players:', players.length);
        
        let successCount = 0;
        let errorCount = 0;
        
        for (const player of players) {
            try {
                // –ù–∞–π—Ç–∏ Telegram ID –∏–≥—Ä–æ–∫–∞
                let telegramId = null;
                
                // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø—Ä—è–º–æ–π Telegram ID –µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω
                if (player.telegramId && player.telegramId.length > 0) {
                    telegramId = player.telegramId;
                } else {
                    // –ü–æ–∏—Å–∫ –ø–æ username –µ—Å–ª–∏ –µ—Å—Ç—å
                    if (player.username) {
                        const userProfile = Object.values(userProfiles).find(profile => 
                            profile.username && profile.username.toLowerCase() === player.username.toLowerCase()
                        );
                        if (userProfile) {
                            telegramId = userProfile.id;
                        }
                    }
                    
                    // –ü–æ–∏—Å–∫ –ø–æ nickname –µ—Å–ª–∏ username –Ω–µ –¥–∞–ª —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
                    if (!telegramId) {
                        const userProfile = Object.values(userProfiles).find(profile => 
                            profile.nickname && profile.nickname.toLowerCase() === player.name.toLowerCase()
                        );
                        if (userProfile) {
                            telegramId = userProfile.id;
                        }
                    }
                }
                
                if (telegramId) {
                    const roleInfo = getRoleInfo(player.role);
                    const message = `üé≠ *–í–∞—à–∞ —Ä–æ–ª—å –≤ –∏–≥—Ä–µ:*\n\n${roleInfo.emoji} **${roleInfo.name}**\n\n${roleInfo.description}\n\n–£–¥–∞—á–∏! üçÄ`;
                    
                    await bot.telegram.sendMessage(
                        telegramId,
                        message,
                        { parse_mode: 'Markdown' }
                    );
                    
                    console.log(`‚úÖ Role sent to ${player.name} (ID: ${telegramId}) -> ${player.role}`);
                    successCount++;
                } else {
                    console.log(`‚ùå Telegram ID not found for player: ${player.name} (@${player.username || 'no_username'})`);
                    console.log(`üí° Add Telegram ID to player or have them use /start command in bot`);
                    errorCount++;
                }
            } catch (error) {
                console.error(`‚ùå Error sending role to ${player.name}:`, error);
                errorCount++;
            }
        }
        
        const message = successCount > 0 ? 
            `‚úÖ –†–æ–ª–∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã: ${successCount}/${players.length}` :
            `‚ö†Ô∏è –†–æ–ª–∏ –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã. –ò–≥—Ä–æ–∫–∏ –¥–æ–ª–∂–Ω—ã –∑–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞ –∫–æ–º–∞–Ω–¥–æ–π /start`;
            
        console.log(message);
        
        res.json({ 
            success: true, 
            sent: successCount, 
            errors: errorCount,
            message: message
        });
        
    } catch (error) {
        console.error('‚ùå Error in send-roles API:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// Helper function to get role information
function getRoleInfo(role) {
    const roleMap = {
        'don': { name: '–î–æ–Ω –ú–∞—Ñ–∏–∏', emoji: 'üëë', description: '–í—ã –ª–∏–¥–µ—Ä –º–∞—Ñ–∏–∏. –ü—Ä–∏–Ω–∏–º–∞–π—Ç–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–∏–µ —Ä–µ—à–µ–Ω–∏—è –∏ —É–±–∏–≤–∞–π—Ç–µ –º–∏—Ä–Ω—ã—Ö –∂–∏—Ç–µ–ª–µ–π.' },
        'mafia': { name: '–ú–∞—Ñ–∏—è', emoji: 'üî¥', description: '–í—ã —á–ª–µ–Ω –º–∞—Ñ–∏–∏. –†–∞–±–æ—Ç–∞–π—Ç–µ —Å –∫–æ–º–∞–Ω–¥–æ–π, —á—Ç–æ–±—ã —É–Ω–∏—á—Ç–æ–∂–∏—Ç—å –≤—Å–µ—Ö –º–∏—Ä–Ω—ã—Ö –∂–∏—Ç–µ–ª–µ–π.' },
        'consigliere': { name: '–ö–æ–Ω—Å–∏–ª—å–µ—Ä–∏', emoji: 'üé≠', description: '–í—ã —Å–æ–≤–µ—Ç–Ω–∏–∫ –º–∞—Ñ–∏–∏. –ü–æ–º–æ–≥–∞–π—Ç–µ –∫–æ–º–∞–Ω–¥–µ –∏ –≤–µ—Ä–±—É–π—Ç–µ –Ω–æ–≤—ã—Ö —Å–æ—é–∑–Ω–∏–∫–æ–≤.' },
        'capo': { name: '–ö–∞–ø–æ', emoji: '‚öîÔ∏è', description: '–í—ã –∫–∞–ø–∏—Ç–∞–Ω –º–∞—Ñ–∏–∏. –ë–ª–æ–∫–∏—Ä—É–π—Ç–µ –¥–µ–π—Å—Ç–≤–∏—è –¥—Ä—É–≥–∏—Ö –∏–≥—Ä–æ–∫–æ–≤ –Ω–æ—á—å—é.' },
        'commissar': { name: '–ö–æ–º–∏—Å—Å–∞—Ä', emoji: 'üîç', description: '–í—ã —Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å. –ü—Ä–æ–≤–µ—Ä—è–π—Ç–µ –∏–≥—Ä–æ–∫–æ–≤ –Ω–æ—á—å—é, —á—Ç–æ–±—ã –Ω–∞–π—Ç–∏ –º–∞—Ñ–∏—é.' },
        'doctor': { name: '–î–æ–∫—Ç–æ—Ä', emoji: 'üíä', description: '–í—ã –ª–µ—á–∏—Ç–µ –∏–≥—Ä–æ–∫–æ–≤ –Ω–æ—á—å—é. –°–ø–∞—Å–∞–π—Ç–µ –∂–∏–∑–Ω–∏ –∏ –∑–∞—â–∏—â–∞–π—Ç–µ –≥–æ—Ä–æ–¥.' },
        'lover': { name: '–õ—é–±–æ–≤–Ω–∏—Ü–∞', emoji: 'üíã', description: '–í—ã –±–ª–æ–∫–∏—Ä—É–µ—Ç–µ –∏–≥—Ä–æ–∫–æ–≤ –Ω–æ—á—å—é, –Ω–µ –¥–∞–≤–∞—è –∏–º –¥–µ–π—Å—Ç–≤–æ–≤–∞—Ç—å.' },
        'bomber': { name: '–ü–æ–¥—Ä—ã–≤–Ω–∏–∫', emoji: 'üí£', description: '–í—ã –º–∏–Ω–∏—Ä—É–µ—Ç–µ –∏–≥—Ä–æ–∫–æ–≤. –ü—Ä–∏ –≤–∞—à–µ–π —Å–º–µ—Ä—Ç–∏ –≤–∑–æ—Ä–≤–µ—Ç–µ –ø–æ—Å–ª–µ–¥–Ω—é—é —Ü–µ–ª—å.' },
        'civilian': { name: '–ú–∏—Ä–Ω—ã–π –∂–∏—Ç–µ–ª—å', emoji: 'üë§', description: '–í—ã –æ–±—ã—á–Ω—ã–π –∂–∏—Ç–µ–ª—å –≥–æ—Ä–æ–¥–∞. –ì–æ–ª–æ—Å—É–π—Ç–µ –¥–Ω–µ–º, —á—Ç–æ–±—ã –Ω–∞–π—Ç–∏ –º–∞—Ñ–∏—é.' },
        'maniac': { name: '–ú–∞–Ω—å—è–∫', emoji: 'üî™', description: '–í—ã –∏–≥—Ä–∞–µ—Ç–µ —Å–∞–º –∑–∞ —Å–µ–±—è. –£–±–∏–≤–∞–π—Ç–µ –∏–≥—Ä–æ–∫–æ–≤ –Ω–æ—á—å—é.' },
        'kamikaze': { name: '–ö–∞–º–∏–∫–∞–¥–∑–µ', emoji: 'üí•', description: '–ü—Ä–∏ –≥–æ–ª–æ—Å–æ–≤–∞–Ω–∏–∏ –∑–∞ –≤–∞—Å –¥–Ω–µ–º –≤—ã –≤–∑—Ä—ã–≤–∞–µ—Ç–µ —Å–ª—É—á–∞–π–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞.' },
        'werewolf': { name: '–û–±–æ—Ä–æ—Ç–µ–Ω—å', emoji: 'üê∫', description: '–í—ã –Ω–µ–π—Ç—Ä–∞–ª—å–Ω–∞—è —Ä–æ–ª—å. –£–±–∏–≤–∞–π—Ç–µ –∏–≥—Ä–æ–∫–æ–≤ –∫–æ–≥–¥–∞ –∞–∫—Ç–∏–≤–Ω—ã.' }
    };
    
    return roleMap[role] || { name: '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è —Ä–æ–ª—å', emoji: '‚ùì', description: '–†–æ–ª—å –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞.' };
}

app.get('/', (req, res) => {
    res.redirect('/balagan/');
});

// Start web server
const PORT = 5000;
app.listen(PORT, '0.0.0.0', () => {
    console.log(`üåê Web server running on port ${PORT}`);
    const webAppUrl = process.env.REPLIT_DEV_DOMAIN ? `https://${process.env.REPLIT_DEV_DOMAIN}/` : 'https://localhost:5000/';
    console.log(`üîó Web App URL: ${webAppUrl}`);
});

// Enable graceful stop
process.once('SIGINT', () => {
    bot.stop('SIGINT');
    process.exit(0);
});
process.once('SIGTERM', () => {
    bot.stop('SIGTERM');
    process.exit(0);
});
